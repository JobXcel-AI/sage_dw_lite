do you see how when I make a card I use orderDict

I need to modify the create dashboard to also use the orderDict

import os
import json
import requests
import logging
from tabulate import tabulate
from collections import OrderedDict

# Metabase API credentials and endpoints
SOURCE_API_URL = "https://sagexcel.jobxcel.report/api"
TARGET_API_URL = "https://brekhus.xcel.report/api"
SOURCE_API_KEY = "mb_blLUnFYZ+diBCC1OY8zBmLXRkKZiRy5f+iFHf1Cj+9E="
TARGET_API_KEY = "mb_N0G2ThcRv3WTjhl+xsbHrv1fuDGA/XfLL4XiRaagXIA="
SOURCE_DATABASE_ID = 2  # Set the source database ID
TARGET_DATABASE_ID = 2  # Set the target database ID

# List of dashboards to migrate
DASHBOARDS = [4]
CARDS = []

HEADERS_SOURCE = {
"x-api-key": SOURCE_API_KEY,
}

HEADERS_TARGET = {
"x-api-key": TARGET_API_KEY,
}

# Configure logger
logging.basicConfig(level=logging.DEBUG, format="%(asctime)s - %(levelname)s - %(message)s")
logger = logging.getLogger(__name__)


def fetch_resource(api_url, endpoint, headers):
try:
response = requests.get(f"{api_url}/{endpoint}", headers=headers, timeout=10)
response.raise_for_status()
return response.json()
except requests.exceptions.RequestException as e:
print(f"Error fetching resource from {api_url}/{endpoint}: {e}")
return None
except json.JSONDecodeError as e:
print(f"Error decoding JSON: {e}")
return None


def create_resource(api_url, endpoint, headers, payload):
try:
# Ensure Content-Type is set to application/json
headers["Content-Type"] = "application/json"
json_payload = json.dumps(payload, indent=4)
response = requests.post(
f"{api_url}/{endpoint}", headers=headers, data=json_payload, timeout=10
)
response.raise_for_status()
return response.json()
except requests.exceptions.RequestException as e:
if e.response is not None:
logger.error(f"Error creating resource: {e}, Response: {e.response.text}")
else:
logger.error(f"Error creating resource: {e}")
return None


def build_table_field_mapping(tables):
"""
Build a mapping of table names and field names from the tables data.
"""
table_mapping = {table["name"].lower(): table["id"] for table in tables}
field_mapping = {
field["id"]: {"name": field["name"], "table_id": table["id"], "table_name": table["name"].lower()}
for table in tables
for field in table.get("fields", [])
}
return table_mapping, field_mapping


def log_field_mappings(source_tables, target_tables, field_mapping):
"""
Log a detailed mapping of source and target tables and fields, ensuring table names and field names are matched.
"""
mappings = []

for source_field_id, source_field_data in field_mapping["source"].items():
source_table_id = source_field_data["table_id"]
source_field_name = source_field_data["name"]
source_table_name = next(
(table["name"] for table in source_tables if table["id"] == source_table_id), "Unknown Table"
)

# Find matching target table and field by name
target_table = next(
(table for table in target_tables if table["name"].lower() == source_table_name.lower()), None
)
if target_table:
target_table_id = target_table["id"]
target_field = next(
(field for field in target_table.get("fields", [])
if field["name"].lower() == source_field_name.lower()), None
)
if target_field:
target_field_id = target_field["id"]
target_table_name = target_table["name"]
target_field_name = target_field["name"]
mappings.append([
source_table_id, source_table_name, source_field_id, source_field_name,
target_table_id, target_table_name, target_field_id, target_field_name
])
else:
mappings.append([
source_table_id, source_table_name, source_field_id, source_field_name,
target_table_id, target_table["name"], "N/A", source_field_name
])
else:
mappings.append([
source_table_id, source_table_name, source_field_id, source_field_name,
"N/A", "N/A", "N/A", source_field_name
])

# Log the table
logger.debug("\n" + tabulate(mappings, headers=[
"Source Table ID", "Source Table Name", "Source Field ID", "Source Field Name",
"Target Table ID", "Target Table Name", "Target Field ID", "Target Field Name"
], tablefmt="grid"))


def get_table_mapping(source_tables, target_tables):
mapping = {}
target_table_lookup = {table["name"].lower(): table["id"] for table in target_tables}
for source_table in source_tables:
source_table_name = source_table["name"].lower()
target_id = target_table_lookup.get(source_table_name)
if target_id:
mapping[source_table["id"]] = target_id
else:
logger.debug(f"Source table '{source_table['name']}' not found in target tables.")
return mapping

def fetch_cards_from_dashboard(api_url, dashboard_id, headers):
"""
Fetch the list of card IDs from a dashboard.

:param api_url: The base URL of the API.
:param dashboard_id: The ID of the dashboard to fetch.
:param headers: Headers for the API request.
:return: A list of card IDs in the dashboard.
"""
dashboard = fetch_resource(api_url, f"dashboard/{dashboard_id}", headers)
if not dashboard:
logger.error(f"Dashboard with ID {dashboard_id} not found.")
return []

dashcards = dashboard.get("dashcards", [])
return [dashcard.get("card_id") for dashcard in dashcards if dashcard.get("card_id") is not None]


def migrate_cards(
source_api_url, target_api_url, headers_source, headers_target,
dashboard_id, source_tables, target_tables, source_field_mapping, target_field_mapping,
source_table_mapping, target_table_mapping
):
"""
Migrate cards from source to target. Update the database, collection, table, field references, and field ids.
"""
if (DASHBOARDS):
# Fetch card IDs from the dashboard
source_card_ids = fetch_cards_from_dashboard(source_api_url, dashboard_id, headers_source)
else:
source_card_ids = CARDS

source_cards = []
card_mapping = {}
# Fetch the card data for each card ID
for card_id in source_card_ids:
card_data = fetch_resource(source_api_url, f"card/{card_id}", headers_source)
if card_data:
source_cards.append(card_data)
else:
logger.warning(f"Card with ID {card_id} not found or could not be retrieved.")

for source_card in source_cards:
if not source_card:
logger.warning("Skipping dashcard without a valid card.")
continue
# Transform the source card JSON
updated_card = source_card.copy()

# Update database ID
if SOURCE_DATABASE_ID != TARGET_DATABASE_ID:
updated_card["database_id"] = TARGET_DATABASE_ID


def update_joins(joins, source_table_mapping, target_table_mapping, source_field_mapping, target_field_mapping):
"""
Update the joins array to map source field IDs to target field IDs and source-table IDs to target-table IDs.
"""
# Reverse the source table mapping for lookup by table ID
reversed_source_table_mapping = {v: k for k, v in source_table_mapping.items()}

for join in joins:
# Update "source-table"
if "source-table" in join:
source_table_id = join["source-table"]
logger.debug(f"Original source-table ID: {source_table_id}")

# Ensure `source_table_id` is an integer
if not isinstance(source_table_id, int):
logger.error(f"Invalid source-table ID: {source_table_id}")
continue

# Get source table name using the reversed mapping
source_table_name = reversed_source_table_mapping.get(source_table_id)
logger.debug(f"Source table name: {source_table_name}")

if source_table_name:
# Get target table ID using source table name
target_table_id = target_table_mapping.get(source_table_name.lower())
logger.debug(f"Target table ID: {target_table_id}")

if target_table_id:
join["source-table"] = target_table_id
else:
logger.warning(f"Target table ID not found for source table name: {source_table_name}")
else:
logger.warning(f"Source table name not found for source-table ID: {source_table_id}")

# Update "condition"
if "condition" in join:
join["condition"] = update_condition(join["condition"], source_field_mapping, target_field_mapping)

def update_condition(condition, source_field_mapping, target_field_mapping):
"""
Updates field references within a condition array.
"""
if isinstance(condition, list):
for i, item in enumerate(condition):
if isinstance(item, list) and len(item) > 1:
# Check if this is a field reference
if item[0] == "field" and isinstance(item[1], int):  # If the second item is a field ID
source_field_id = item[1]
source_field_name = source_field_mapping.get(source_field_id, {}).get("name")
if source_field_name:
target_field_id = next(
(field_id for field_id, field_data in target_field_mapping.items()
if field_data["name"] == source_field_name),
source_field_id  # Default to the original ID if no match
)
condition[i][1] = target_field_id  # Replace with target field ID
elif isinstance(item, list):  # Recurse into nested conditions
condition[i] = update_condition(item, source_field_mapping, target_field_mapping)

return condition

def map_field_id(source_field_id, source_field_mapping, target_field_mapping):
"""
Map a source field ID to a target field ID using source and target field mappings.

:param source_field_id: The source field ID to map.
:param source_field_mapping: Dictionary of source field mappings.
:param target_field_mapping: Dictionary of target field mappings.
:return: Mapped target field ID or the original source field ID if no match is found.
"""
source_field_name = source_field_mapping.get(source_field_id, {}).get("name")
source_table_name = source_field_mapping.get(source_field_id, {}).get("table_name")

if source_field_name and source_table_name:
# Map source field and table names to target field ID
target_field_id = next(
(
field_id for field_id, field_data in target_field_mapping.items()
if field_data["name"] == source_field_name and
field_data.get("table_name", "").lower() == source_table_name.lower()
),
source_field_id  # Default to original if no match
)
return target_field_id
else:
# Log a warning if the source field name or table name is missing
logger.warning(f"Field or table name missing for source field ID {source_field_id}.")
return source_field_id

def update_aggregation_options(aggregation_options, source_field_mapping, target_field_mapping):
"""
Update field references within aggregation-options, including "default" fields.
"""
if isinstance(aggregation_options, list):
for i, option in enumerate(aggregation_options):
if isinstance(option, list):
# Recursively handle nested structures
update_aggregation_options(option, source_field_mapping, target_field_mapping)
elif option == "field" and i + 1 < len(aggregation_options):
# Map the field ID
if isinstance(aggregation_options[i + 1], int):
source_field_id = aggregation_options[i + 1]
aggregation_options[i + 1] = map_field_id(source_field_id, source_field_mapping, target_field_mapping)
elif isinstance(option, dict) and "default" in option:
# Handle "default" field
default_value = option["default"]
if isinstance(default_value, list) and default_value[0] == "field" and isinstance(default_value[1], int):
source_field_id = default_value[1]
option["default"][1] = map_field_id(source_field_id, source_field_mapping, target_field_mapping)

def update_aggregations(aggregations, source_field_mapping, target_field_mapping):
"""
Update field references within the aggregations array, including in aggregation-options.
"""
for aggregation in aggregations:
if isinstance(aggregation, list):
for i, item in enumerate(aggregation):
if isinstance(item, list):
# Handle nested structures or aggregation-options
update_aggregations([item], source_field_mapping, target_field_mapping)
elif item == "field" and i + 1 < len(aggregation):
# Map the field ID
if isinstance(aggregation[i + 1], int):
source_field_id = aggregation[i + 1]
aggregation[i + 1] = map_field_id(source_field_id, source_field_mapping, target_field_mapping)
elif isinstance(item, dict) and "default" in item:
# Handle "default" field in aggregation-options
update_aggregation_options([item], source_field_mapping, target_field_mapping)

def update_field_ref(field_ref, source_field_mapping, target_field_mapping):
if isinstance(field_ref, list):
if len(field_ref) > 1 and isinstance(field_ref[1], int):
# Look up the source field name using the field ID
field_ref[1]  = map_field_id(field_ref[1], source_field_mapping, target_field_mapping)
elif isinstance(field_ref, int):
# Handle cases where field_ref is a simple integer (field ID)
field_ref = map_field_id(field_ref, source_field_mapping, target_field_mapping)
return field_ref

def update_query_recursively(query, is_top_level=True):
if isinstance(query, dict):

if "aggregation" in query:
update_aggregations(query["aggregation"], source_field_mapping, target_field_mapping)

# Process "source-table"
if "source-table" in query:
source_table_name = next(
(table["name"] for table in source_tables if table["id"] == query["source-table"]), None
)
if source_table_name:
query["source-table"] = next(
(table["id"] for table in target_tables if table["name"] == source_table_name),
query["source-table"]
)

# Process "table_id"
if "table_id" in query:
source_table_name = next(
(table["name"] for table in source_tables if table["id"] == query["table_id"]), None
)
if source_table_name:
query["table_id"] = next(
(table["id"] for table in target_tables if table["name"] == source_table_name),
query["table_id"]
)

# Process "field_ref"
if "field_ref" in query:
query["field_ref"] = update_field_ref(
query["field_ref"], source_field_mapping, target_field_mapping
)

# Process "joins"
if "joins" in query:
update_joins(query["joins"], source_table_mapping, target_table_mapping, source_field_mapping,
target_field_mapping)

# Process "breakout"
if "breakout" in query:
for breakout in query["breakout"]:
if isinstance(breakout, list) and len(breakout) > 1:
if isinstance(breakout[1], int):  # Process field ID in breakout
breakout[1] = map_field_id(breakout[1], source_field_mapping, target_field_mapping)
elif isinstance(breakout[1], list):  # Handle nested field refs
breakout[1] = update_field_ref(breakout[1], source_field_mapping, target_field_mapping)

# Process "condition"
if "condition" in query:
query["condition"] = update_condition(query["condition"], source_field_mapping,
target_field_mapping)

# Process "aggregation"
if "aggregation" in query:
for aggregation in query["aggregation"]:
if isinstance(aggregation, list) and len(aggregation) > 1:
aggregation[1] = update_field_ref(aggregation[1], source_field_mapping,
target_field_mapping)

# If we are at the top level, process `dataset_query` specifically
if is_top_level and "dataset_query" in query:
query["dataset_query"] = update_query_recursively(query.get("dataset_query", {}),
is_top_level=False)
return query

# Process "source-query"
if "source-query" in query:
query["source-query"] = update_query_recursively(query["source-query"], is_top_level=False)

# Process "query" (specific to dataset_query)
if "query" in query:
query["query"] = update_query_recursively(query["query"], is_top_level=False)

elif isinstance(query, list):
for i, item in enumerate(query):
query[i] = update_query_recursively(item, is_top_level=False)

return query

# Begin by updating the top-level source_card
dataset_query = update_query_recursively(source_card)
updated_card["dataset_query"] = dataset_query

# Update table_id in the card metadata
if "table_id" in updated_card:
source_table_name = next(
(table["name"] for table in source_tables if table["id"] == updated_card["table_id"]), None)
if source_table_name:
updated_card["table_id"] = next(
(table["id"] for table in target_tables if table["name"] == source_table_name),
updated_card["table_id"]
)

# Update result_metadata field ids and field_ref
if "result_metadata" in updated_card:
for metadata in updated_card["result_metadata"]:
# Update id directly (next to fingerprint)
if "id" in metadata:
source_field_id = metadata["id"]
source_field_name = source_field_mapping.get(source_field_id, {}).get("name")
if source_field_name:
metadata["id"] = next(
(field_id for field_id, field_data in target_field_mapping.items()
if field_data["name"] == source_field_name),
metadata["id"]
)

# Update field_ref
if "field_ref" in metadata:
metadata["field_ref"] = update_field_ref(
metadata["field_ref"], source_field_mapping, target_field_mapping
)
updated_card = OrderedDict()
updated_card["cache_invalidated_at"] = source_card.get("cache_invalidated_at", None)
updated_card["description"] = source_card.get("description", "") or None
updated_card["archived"] = source_card.get("archived", False)
updated_card["view_count"] = source_card.get("view_count", 0)
updated_card["collection_position"] = source_card.get("collection_position", None)
updated_card["table_id"] = source_card.get("table_id", None)
updated_card["can_run_adhoc_query"] = source_card.get("can_run_adhoc_query", True)
updated_card["result_metadata"] = source_card.get("result_metadata", [])
updated_card["creator"] = source_card.get("creator", {})
updated_card["database_id"] = source_card.get("database_id", TARGET_DATABASE_ID)
updated_card["enable_embedding"] = source_card.get("enable_embedding", False)
updated_card["collection_id"] = None
updated_card["query_type"] = source_card.get("query_type", "query")
updated_card["name"] = source_card.get("name", "Unnamed")
updated_card["type"] = source_card.get("type", "question")
updated_card["dataset_query"] = source_card.get("dataset_query", {})
updated_card["visualization_settings"] = source_card.get("visualization_settings", {})
updated_card["last_query_start"] = source_card.get("last_query_start", None)
updated_card["last_used_at"] = source_card.get("last_used_at", None)
updated_card["created_at"] = source_card.get("created_at", None)
updated_card["updated_at"] = source_card.get("updated_at", None)
updated_card["id"] = source_card.get("id")
updated_card["initially_published_at"] = source_card.get("initially_published_at", None)
updated_card["can_write"] = source_card.get("can_write", True)
updated_card["dashboard_count"] = source_card.get("dashboard_count", 0)
updated_card["average_query_time"] = source_card.get("average_query_time", None)
updated_card["creator_id"] = source_card.get("creator_id", None)
updated_card["moderation_reviews"] = source_card.get("moderation_reviews", [])
updated_card["made_public_by_id"] = source_card.get("made_public_by_id", None)
updated_card["embedding_params"] = source_card.get("embedding_params", None)
updated_card["cache_ttl"] = source_card.get("cache_ttl", None)
updated_card["parameter_mappings"] = source_card.get("parameter_mappings", [])
updated_card["display"] = source_card.get("display", "table")
updated_card["entity_id"] = source_card.get("entity_id", None)
updated_card["collection_preview"] = source_card.get("collection_preview", False)
updated_card["last-edit-info"] = source_card.get("last-edit-info", {})
updated_card["collection"] = source_card.get("collection", {})
updated_card["metabase_version"] = source_card.get("metabase_version", None)
updated_card["parameters"] = source_card.get("parameters", [])
updated_card["parameter_usage_count"] = source_card.get("parameter_usage_count", 0)
updated_card["public_uuid"] = source_card.get("public_uuid", None)

json_payload = json.dumps(updated_card, indent=4)
logger.debug(f"Updated card JSON: {json_payload}")
created_card = create_resource(target_api_url, "card", headers_target, updated_card)
if created_card:
card_mapping[source_card["id"]] = created_card["id"]
logger.info(f"Card '{updated_card.get('name', 'Unnamed')}, Source Card ID: {source_card['id']}, Target Card ID: {created_card['id']}: ' migrated successfully.")
else:
logger.error(f"Failed to create card: {updated_card.get('name', 'Unnamed')}")

return card_mapping


def save_json_payload(json_payload, filename="updated_card.json"):
"""
Save JSON payload to a file if in debug mode.

:param json_payload: JSON payload to save.
:param filename: Name of the file to save the payload to.
"""
if logger.getEffectiveLevel() <= logging.DEBUG:
try:
project_dir = os.path.dirname(os.path.abspath(__file__))  # Project directory
debug_dir = os.path.join(project_dir, "debug_payloads")
os.makedirs(debug_dir, exist_ok=True)  # Ensure the directory exists
file_path = os.path.join(debug_dir, filename)

with open(file_path, "w", encoding="utf-8") as file:
json.dump(json_payload, file, indent=4)

logger.debug(f"JSON payload saved to {file_path}")
except Exception as e:
logger.error(f"Failed to save JSON payload: {e}")
else:
logger.debug("Debug mode is off; payload not saved.")

def update_dashboard_with_cards(source_dashboard, card_mapping):
if not source_dashboard:
logger.error("Source dashboard data is empty.")
return None

for dashcard in source_dashboard.get("dashcards", []):
old_card_id = dashcard.get("card_id")
if old_card_id in card_mapping:
dashcard["card_id"] = card_mapping[old_card_id]

logger.info("Dashboard updated with new card mappings.")
return source_dashboard


def main():
logger.info("Starting migration process...")

# Migrate collections
source_metadata = fetch_resource(SOURCE_API_URL, f"database/{SOURCE_DATABASE_ID}/metadata", HEADERS_SOURCE)
target_metadata = fetch_resource(TARGET_API_URL, f"database/{TARGET_DATABASE_ID}/metadata", HEADERS_TARGET)

source_tables = source_metadata.get("tables", [])
target_tables = target_metadata.get("tables", [])

source_table_mapping, source_field_mapping = build_table_field_mapping(source_tables)
target_table_mapping, target_field_mapping = build_table_field_mapping(target_tables)

field_mapping = {"source": source_field_mapping, "target": target_field_mapping}

log_field_mappings(source_tables, target_tables, field_mapping)

if (DASHBOARDS):
for dashboard_id in DASHBOARDS:
logger.info(f"Processing dashboard ID: {dashboard_id}")
source_dashboard = fetch_resource(SOURCE_API_URL, f"dashboard/{dashboard_id}", HEADERS_SOURCE)
if not source_dashboard:
logger.error(f"Failed to fetch dashboard ID {dashboard_id}. Skipping.")
continue

card_mapping = migrate_cards(
SOURCE_API_URL, TARGET_API_URL, HEADERS_SOURCE, HEADERS_TARGET,
dashboard_id, source_tables, target_tables, source_field_mapping, target_field_mapping,
source_table_mapping, target_table_mapping
)

# Update dashboard with new cards
updated_dashboard = update_dashboard_with_cards(source_dashboard, card_mapping)
if not updated_dashboard:
logger.error(f"Failed to update dashboard ID {dashboard_id}. Skipping.")
continue

# Create the updated dashboard in the target
create_resource(TARGET_API_URL, "dashboard", HEADERS_TARGET, updated_dashboard)
logger.info(f"Dashboard ID {dashboard_id} migrated successfully.")
else:
card_mapping = migrate_cards(
SOURCE_API_URL, TARGET_API_URL, HEADERS_SOURCE, HEADERS_TARGET,
[], source_tables, target_tables, source_field_mapping, target_field_mapping,
source_table_mapping, target_table_mapping
)
logger.info(f"New card mappings. {card_mapping}")

logger.info("Migration process completed.")


if __name__ == "__main__":
main()

here is the json file we need to replicate.

{
"description": null,
"archived": false,
"view_count": 538,
"collection_position": null,
"dashcards": [
{
"size_x": 24,
"dashboard_tab_id": null,
"series": [],
"action_id": null,
"collection_authority_level": null,
"card": {
"cache_invalidated_at": null,
"description": null,
"archived": false,
"view_count": 409,
"collection_position": null,
"table_id": 1074,
"result_metadata": [
{
"description": null,
"semantic_type": "type/Category",
"coercion_strategy": null,
"name": "job_number_job_name",
"settings": null,
"fk_target_field_id": null,
"field_ref": [
"field",
"job_number_job_name",
{
"base-type": "type/Text"
}
],
"effective_type": "type/Text",
"id": 23838,
"visibility_type": "normal",
"display_name": "Job Number Job Name",
"fingerprint": {
"global": {
"distinct-count": 11,
"nil%": 0.0
},
"type": {
"type/Text": {
"percent-json": 0.0,
"percent-url": 0.0,
"percent-email": 0.0,
"percent-state": 0.0,
"average-length": 24.454545454545453
}
}
},
"base_type": "type/Text"
},
{
"description": null,
"semantic_type": "type/Category",
"coercion_strategy": null,
"name": "job_status",
"settings": null,
"fk_target_field_id": null,
"field_ref": [
"field",
"job_status",
{
"base-type": "type/Text"
}
],
"effective_type": "type/Text",
"id": 23834,
"visibility_type": "normal",
"display_name": "Job Status",
"fingerprint": {
"global": {
"distinct-count": 2,
"nil%": 0.0
},
"type": {
"type/Text": {
"percent-json": 0.0,
"percent-url": 0.0,
"percent-email": 0.0,
"percent-state": 0.0,
"average-length": 7.090909090909091
}
}
},
"base_type": "type/Text"
},
{
"description": null,
"semantic_type": null,
"coercion_strategy": null,
"unit": "day",
"name": "project_complete_date",
"settings": null,
"fk_target_field_id": null,
"field_ref": [
"field",
"project_complete_date",
{
"base-type": "type/Date",
"temporal-unit": "day"
}
],
"effective_type": "type/Date",
"id": 23797,
"visibility_type": "normal",
"display_name": "Project Complete Date",
"fingerprint": {
"global": {
"distinct-count": 6,
"nil%": 0.5454545454545455
},
"type": {
"type/DateTime": {
"earliest": "2023-06-15",
"latest": "2023-12-20"
}
}
},
"base_type": "type/Date"
},
{
"description": null,
"semantic_type": "type/Quantity",
"coercion_strategy": null,
"name": "job_number",
"settings": null,
"fk_target_field_id": null,
"field_ref": [
"field",
"job_number",
{
"base-type": "type/BigInteger"
}
],
"effective_type": "type/BigInteger",
"id": 23779,
"visibility_type": "normal",
"display_name": "Job Number",
"fingerprint": {
"global": {
"distinct-count": 11,
"nil%": 0.0
},
"type": {
"type/Number": {
"min": 1.0,
"q1": 202.5,
"q3": 221.75,
"max": 224.0,
"sd": 65.10425206055007,
"avg": 194.1818181818182
}
}
},
"base_type": "type/BigInteger"
},
{
"description": null,
"semantic_type": "type/CreationDate",
"coercion_strategy": null,
"unit": "day",
"name": "project_start_date",
"settings": null,
"fk_target_field_id": null,
"field_ref": [
"field",
"project_start_date",
{
"base-type": "type/Date",
"temporal-unit": "day"
}
],
"effective_type": "type/Date",
"id": 23825,
"visibility_type": "normal",
"display_name": "Project Start Date",
"fingerprint": {
"global": {
"distinct-count": 7,
"nil%": 0.3636363636363636
},
"type": {
"type/DateTime": {
"earliest": "2023-01-01",
"latest": "2023-07-01"
}
}
},
"base_type": "type/Date"
},
{
"display_name": "Sum of Max of Sum of Total Contract Amount",
"field_ref": [
"aggregation",
0
],
"base_type": "type/Decimal",
"effective_type": "type/Decimal",
"name": "sum",
"semantic_type": null,
"fingerprint": {
"global": {
"distinct-count": 356,
"nil%": 0.0
},
"type": {
"type/Number": {
"min": 0.0,
"q1": 1401866.3408346092,
"q3": 3867512.297723551,
"max": 4975449.41,
"sd": 1430704.353476612,
"avg": 2610110.5615686276
}
}
}
},
{
"display_name": "Sum of Max of Sum of Original Budget Amount",
"field_ref": [
"aggregation",
1
],
"base_type": "type/Decimal",
"effective_type": "type/Decimal",
"name": "sum_2",
"semantic_type": null,
"fingerprint": {
"global": {
"distinct-count": 357,
"nil%": 0.0
},
"type": {
"type/Number": {
"min": 0.0,
"q1": 1201522.7682775764,
"q3": 3261960.8730000006,
"max": 4584438.29,
"sd": 1254895.5072387254,
"avg": 2280384.8771988796
}
}
}
},
{
"display_name": "Sum of Max of Sum of Estimated Gross Profit",
"field_ref": [
"aggregation",
2
],
"base_type": "type/Decimal",
"effective_type": "type/Decimal",
"name": "sum_3",
"semantic_type": null,
"fingerprint": {
"global": {
"distinct-count": 357,
"nil%": 0.0
},
"type": {
"type/Number": {
"min": -379155.62,
"q1": 148548.51749999996,
"q3": 456590.38750347315,
"max": 954675.96,
"sd": 224624.14088956363,
"avg": 326746.5823809523
}
}
}
},
{
"display_name": "Sum of Percent Complete",
"field_ref": [
"aggregation",
3
],
"base_type": "type/Float",
"effective_type": "type/Float",
"name": "sum_4",
"semantic_type": null,
"fingerprint": {
"global": {
"distinct-count": 357,
"nil%": 0.002801120448179272
},
"type": {
"type/Number": {
"min": 0.03693316720172409,
"q1": 1.1621947358511897,
"q3": 1.2758850246797575,
"max": 1.329405609528941,
"sd": 0.13863965888764085,
"avg": 1.2025576915553637
}
}
}
},
{
"display_name": "Sum of Max of Sum of Invoice Billed",
"field_ref": [
"aggregation",
4
],
"base_type": "type/Decimal",
"effective_type": "type/Decimal",
"name": "sum_5",
"semantic_type": null,
"fingerprint": {
"global": {
"distinct-count": 354,
"nil%": 0.0
},
"type": {
"type/Number": {
"min": 0.0,
"q1": 1114003.342685521,
"q3": 3358757.416018518,
"max": 6465473.0,
"sd": 1411475.0993258778,
"avg": 2307820.233165266
}
}
}
},
{
"display_name": "Sum of Sum of Job Cost - Job Number â†’ Cost Amount",
"semantic_type": "type/Cost",
"field_ref": [
"aggregation",
5
],
"base_type": "type/Decimal",
"effective_type": "type/Decimal",
"name": "sum_6",
"fingerprint": {
"global": {
"distinct-count": 357,
"nil%": 0.0
},
"type": {
"type/Number": {
"min": 293.19,
"q1": 1443571.9101493715,
"q3": 4093071.8329454893,
"max": 5341718.35,
"sd": 1534734.0876289506,
"avg": 2754834.404565826
}
}
}
},
{
"display_name": "Sum of Income",
"field_ref": [
"aggregation",
6
],
"base_type": "type/Decimal",
"effective_type": "type/Decimal",
"name": "sum_7",
"semantic_type": null,
"fingerprint": {
"global": {
"distinct-count": 357,
"nil%": 0.0
},
"type": {
"type/Number": {
"min": -2101899.68,
"q1": -823488.4020432212,
"q3": -50106.485314311474,
"max": 1384875.17,
"sd": 615675.5805272193,
"avg": -447014.17140056024
}
}
}
},
{
"display_name": "Sum of Overbilled",
"field_ref": [
"aggregation",
7
],
"base_type": "type/Float",
"effective_type": "type/Float",
"name": "sum_8",
"semantic_type": null,
"fingerprint": {
"global": {
"distinct-count": 334,
"nil%": 0.0
},
"type": {
"type/Number": {
"min": 0.0,
"q1": 274863.7134327834,
"q3": 1338884.475469635,
"max": 2897381.432598487,
"sd": 719879.5127297183,
"avg": 863042.7395122421
}
}
}
},
{
"display_name": "Sum of Underbilled",
"field_ref": [
"aggregation",
8
],
"base_type": "type/Float",
"effective_type": "type/Float",
"name": "sum_9",
"semantic_type": null,
"fingerprint": {
"global": {
"distinct-count": 24,
"nil%": 0.0
},
"type": {
"type/Number": {
"min": -577704.5063669244,
"q1": -1592.8107783038267,
"q3": 0.0,
"max": 0.0,
"sd": 56037.65928889941,
"avg": -10295.499291427283
}
}
}
},
{
"display_name": "Sum of Earned Revenue",
"field_ref": [
"aggregation",
9
],
"base_type": "type/Float",
"effective_type": "type/Float",
"name": "sum_10",
"semantic_type": null,
"fingerprint": {
"global": {
"distinct-count": 357,
"nil%": 0.002801120448179272
},
"type": {
"type/Number": {
"min": 0.0,
"q1": 1645038.2549542151,
"q3": 4693672.409208836,
"max": 6613849.359204726,
"sd": 1766018.9948687607,
"avg": 3169445.471906828
}
}
}
},
{
"display_name": "Sum of Cost of Revenue",
"field_ref": [
"aggregation",
10
],
"base_type": "type/Float",
"effective_type": "type/Float",
"name": "sum_11",
"semantic_type": null,
"fingerprint": {
"global": {
"distinct-count": 357,
"nil%": 0.002801120448179272
},
"type": {
"type/Number": {
"min": -262812.2419909225,
"q1": 1499727.8903967645,
"q3": 4229746.032817744,
"max": 5659173.399204726,
"sd": 1578803.0395066754,
"avg": 2841781.062047278
}
}
}
},
{
"display_name": "Sum of Max of Gross Profit",
"field_ref": [
"aggregation",
11
],
"base_type": "type/Decimal",
"effective_type": "type/Decimal",
"name": "sum_12",
"semantic_type": null,
"fingerprint": {
"global": {
"distinct-count": 357,
"nil%": 0.0
},
"type": {
"type/Number": {
"min": -379155.62,
"q1": 148548.51749999996,
"q3": 456590.38750347315,
"max": 954675.96,
"sd": 224624.14088956363,
"avg": 326746.5823809523
}
}
}
}
],
"initially_published_at": null,
"can_write": true,
"database_id": 2,
"enable_embedding": false,
"collection_id": null,
"query_type": "query",
"name": "Over / Under Billings",
"last_used_at": "2025-02-12T07:21:09.34919Z",
"type": "question",
"query_average_duration": 316,
"creator_id": 3,
"moderation_reviews": [],
"updated_at": "2025-01-02T14:48:44.138545Z",
"made_public_by_id": null,
"embedding_params": null,
"cache_ttl": null,
"dataset_query": {
"database": 2,
"type": "query",
"query": {
"expressions": {
"Overbilled": [
"case",
[
[
[
">",
[
"-",
[
"field",
"Earned Revenue",
{
"base-type": "type/Float"
}
],
[
"field",
"max_4",
{
"base-type": "type/Decimal"
}
]
],
0
],
[
"-",
[
"field",
"Earned Revenue",
{
"base-type": "type/Float"
}
],
[
"field",
"max_4",
{
"base-type": "type/Decimal"
}
]
]
]
],
{
"default": 0
}
],
"Underbilled": [
"case",
[
[
[
"<",
[
"-",
[
"field",
"Earned Revenue",
{
"base-type": "type/Float"
}
],
[
"field",
"max_4",
{
"base-type": "type/Decimal"
}
]
],
0
],
[
"-",
[
"field",
"Earned Revenue",
{
"base-type": "type/Float"
}
],
[
"field",
"max_4",
{
"base-type": "type/Decimal"
}
]
]
]
],
{
"default": 0
}
],
"Cost of Revenue": [
"-",
[
"field",
"Earned Revenue",
{
"base-type": "type/Float"
}
],
[
"field",
"max_6",
{
"base-type": "type/Decimal"
}
]
]
},
"breakout": [
[
"field",
"job_number_job_name",
{
"base-type": "type/Text"
}
],
[
"field",
"job_status",
{
"base-type": "type/Text"
}
],
[
"field",
"project_complete_date",
{
"base-type": "type/Date",
"temporal-unit": "day"
}
],
[
"field",
"job_number",
{
"base-type": "type/BigInteger"
}
],
[
"field",
"project_start_date",
{
"base-type": "type/Date",
"temporal-unit": "day"
}
]
],
"aggregation": [
[
"sum",
[
"field",
"max",
{
"base-type": "type/Decimal"
}
]
],
[
"sum",
[
"field",
"max_2",
{
"base-type": "type/Decimal"
}
]
],
[
"sum",
[
"field",
"max_3",
{
"base-type": "type/Decimal"
}
]
],
[
"sum",
[
"field",
"Percent Complete",
{
"base-type": "type/Float"
}
]
],
[
"sum",
[
"field",
"max_4",
{
"base-type": "type/Decimal"
}
]
],
[
"sum",
[
"field",
"sum",
{
"base-type": "type/Decimal"
}
]
],
[
"sum",
[
"field",
"Income",
{
"base-type": "type/Decimal"
}
]
],
[
"sum",
[
"expression",
"Overbilled",
{
"base-type": "type/Float"
}
]
],
[
"sum",
[
"expression",
"Underbilled",
{
"base-type": "type/Float"
}
]
],
[
"sum",
[
"field",
"Earned Revenue",
{
"base-type": "type/Float"
}
]
],
[
"sum",
[
"expression",
"Cost of Revenue",
{
"base-type": "type/Float"
}
]
],
[
"sum",
[
"field",
"max_6",
{
"base-type": "type/Decimal"
}
]
]
],
"source-query": {
"joins": [
{
"strategy": "inner-join",
"alias": "Job Cost - Job Number",
"condition": [
"=",
[
"field",
"job_number",
{
"base-type": "type/BigInteger"
}
],
[
"field",
23899,
{
"base-type": "type/BigInteger",
"join-alias": "Job Cost - Job Number"
}
]
],
"source-table": 1077
}
],
"aggregation": [
[
"max",
[
"field",
"sum",
{
"base-type": "type/Decimal"
}
]
],
[
"max",
[
"field",
"sum_3",
{
"base-type": "type/Decimal"
}
]
],
[
"max",
[
"field",
"sum_5",
{
"base-type": "type/Decimal"
}
]
],
[
"aggregation-options",
[
"/",
[
"sum",
[
"field",
23893,
{
"base-type": "type/Decimal",
"join-alias": "Job Cost - Job Number"
}
]
],
[
"max",
[
"field",
"sum_3",
{
"base-type": "type/Decimal"
}
]
]
],
{
"name": "Percent Complete",
"display-name": "Percent Complete"
}
],
[
"max",
[
"field",
"sum_2",
{
"base-type": "type/Decimal"
}
]
],
[
"sum",
[
"field",
23893,
{
"base-type": "type/Decimal",
"join-alias": "Job Cost - Job Number"
}
]
],
[
"max",
[
"field",
"sum_4",
{
"base-type": "type/Decimal"
}
]
],
[
"aggregation-options",
[
"-",
[
"max",
[
"field",
"sum_2",
{
"base-type": "type/Decimal"
}
]
],
[
"sum",
[
"field",
23893,
{
"base-type": "type/Decimal",
"join-alias": "Job Cost - Job Number"
}
]
]
],
{
"name": "Income",
"display-name": "Income"
}
],
[
"aggregation-options",
[
"*",
[
"max",
[
"field",
"sum",
{
"base-type": "type/Decimal"
}
]
],
[
"/",
[
"sum",
[
"field",
23893,
{
"base-type": "type/Decimal",
"join-alias": "Job Cost - Job Number"
}
]
],
[
"max",
[
"field",
"sum_3",
{
"base-type": "type/Decimal"
}
]
]
]
],
{
"name": "Earned Revenue",
"display-name": "Earned Revenue"
}
],
[
"max",
[
"field",
"Gross Profit",
{
"base-type": "type/Decimal"
}
]
]
],
"breakout": [
[
"field",
"job_number_job_name",
{
"base-type": "type/Text"
}
],
[
"field",
"job_number",
{
"base-type": "type/BigInteger"
}
],
[
"field",
"job_status",
{
"base-type": "type/Text"
}
],
[
"field",
"project_complete_date",
{
"base-type": "type/Date",
"temporal-unit": "day"
}
],
[
"field",
"project_start_date",
{
"base-type": "type/Date",
"temporal-unit": "day"
}
]
],
"source-query": {
"source-table": 1074,
"breakout": [
[
"field",
23838,
{
"base-type": "type/Text"
}
],
[
"field",
23834,
{
"base-type": "type/Text"
}
],
[
"field",
23779,
{
"base-type": "type/BigInteger"
}
],
[
"field",
23797,
{
"base-type": "type/Date",
"temporal-unit": "day"
}
],
[
"field",
23825,
{
"base-type": "type/Date",
"temporal-unit": "day"
}
]
],
"aggregation": [
[
"sum",
[
"field",
23823,
{
"base-type": "type/Decimal"
}
]
],
[
"sum",
[
"field",
23805,
{
"base-type": "type/Decimal"
}
]
],
[
"sum",
[
"field",
23796,
{
"base-type": "type/Decimal"
}
]
],
[
"sum",
[
"field",
23791,
{
"base-type": "type/Decimal"
}
]
],
[
"sum",
[
"field",
23789,
{
"base-type": "type/Decimal"
}
]
],
[
"aggregation-options",
[
"-",
[
"sum",
[
"field",
23823,
{
"base-type": "type/Decimal"
}
]
],
[
"sum",
[
"field",
23791,
{
"base-type": "type/Decimal"
}
]
]
],
{
"name": "Gross Profit",
"display-name": "Gross Profit"
}
]
]
}
}
}
},
"id": 40,
"parameter_mappings": [],
"display": "table",
"entity_id": "kqpJurAbRQLnbkC31SZB3",
"collection_preview": true,
"visualization_settings": {
"table.column_formatting": [
{
"columns": [
"sum_9"
],
"type": "single",
"operator": "<",
"value": 0,
"color": "#F7C4C4",
"highlight_row": true,
"id": 0
}
],
"table.pivot_column": "job_number_job_name",
"table.cell_column": "sum",
"table.columns": [
{
"name": "job_number_job_name",
"enabled": true
},
{
"name": "job_status",
"enabled": false
},
{
"name": "project_complete_date",
"enabled": false
},
{
"name": "sum",
"enabled": true
},
{
"name": "sum_2",
"enabled": true
},
{
"name": "sum_3",
"enabled": true
},
{
"name": "sum_4",
"enabled": true
},
{
"name": "sum_5",
"enabled": true
},
{
"name": "sum_6",
"enabled": true
},
{
"name": "sum_7",
"enabled": true
},
{
"name": "sum_8",
"enabled": true
},
{
"name": "sum_9",
"enabled": true
},
{
"name": "sum_10",
"enabled": true
},
{
"name": "sum_11",
"enabled": true
},
{
"name": "sum_12",
"enabled": true
},
{
"name": "job_number",
"enabled": false
},
{
"name": "project_start_date",
"enabled": false
}
],
"column_settings": {
"[\"name\",\"sum_11\"]": {
"column_title": "Cost of Revenue",
"number_style": "currency",
"currency_in_header": false,
"decimals": 0
},
"[\"name\",\"sum\"]": {
"column_title": "Total Contract",
"number_style": "currency",
"currency_in_header": false,
"decimals": 0
},
"[\"name\",\"sum_9\"]": {
"column_title": "Underbilled",
"number_style": "currency",
"currency_in_header": false,
"decimals": 0
},
"[\"name\",\"sum_5\"]": {
"column_title": "Billed",
"number_style": "currency",
"currency_in_header": false,
"decimals": 0
},
"[\"name\",\"sum_4\"]": {
"column_title": "Percent Complete",
"number_style": "percent",
"decimals": 0
},
"[\"name\",\"sum_3\"]": {
"column_title": "Estimated Gross Profit",
"number_style": "currency",
"currency_in_header": false,
"decimals": 0
},
"[\"name\",\"sum_12\"]": {
"column_title": "Gross Profit",
"number_style": "currency",
"currency_in_header": false,
"decimals": 0
},
"[\"name\",\"sum_7\"]": {
"column_title": "Income",
"number_style": "currency",
"currency_in_header": false,
"decimals": 0
},
"[\"name\",\"sum_8\"]": {
"column_title": "Overbilled",
"number_style": "currency",
"currency_in_header": false,
"decimals": 0
},
"[\"name\",\"sum_6\"]": {
"column_title": "Costs",
"decimals": 0,
"currency_in_header": false
},
"[\"name\",\"sum_2\"]": {
"column_title": "Est. Cost at Completion",
"number_style": "currency",
"currency_in_header": false,
"decimals": 0
},
"[\"name\",\"sum_10\"]": {
"column_title": "Earned Revenue",
"number_style": "currency",
"currency_in_header": false,
"decimals": 0
}
}
},
"metabase_version": "v0.50.26 (5a65f46)",
"parameters": [],
"created_at": "2025-01-02T00:47:41.562649Z",
"public_uuid": null
},
"updated_at": "2025-01-14T22:27:12.356416Z",
"col": 0,
"id": 38,
"parameter_mappings": [
{
"parameter_id": "ada0ab44",
"card_id": 40,
"target": [
"dimension",
[
"field",
"job_number",
{
"base-type": "type/BigInteger"
}
]
]
},
{
"parameter_id": "731098",
"card_id": 40,
"target": [
"dimension",
[
"field",
"job_status",
{
"base-type": "type/Text"
}
]
]
},
{
"parameter_id": "704e61f0",
"card_id": 40,
"target": [
"dimension",
[
"field",
"project_complete_date",
{
"base-type": "type/Date"
}
]
]
},
{
"parameter_id": "78d9663b",
"card_id": 40,
"target": [
"dimension",
[
"field",
"project_start_date",
{
"base-type": "type/Date"
}
]
]
},
{
"parameter_id": "afa08c41",
"card_id": 40,
"target": [
"dimension",
[
"field",
"max_6",
{
"base-type": "type/Decimal"
}
]
]
}
],
"card_id": 40,
"entity_id": "O4RiUiWB_jLYru3Ad1u0t",
"visualization_settings": {
"column_settings": {
"[\"name\",\"job_number_job_name\"]": {
"click_behavior": {
"parameterMapping": {
"[\"dimension\",[\"field\",23779,{\"base-type\":\"type/BigInteger\"}]]": {
"source": {
"type": "column",
"id": "job_number",
"name": "Job Number"
},
"target": {
"type": "dimension",
"id": "[\"dimension\",[\"field\",23779,{\"base-type\":\"type/BigInteger\"}]]",
"dimension": [
"dimension",
[
"field",
23779,
{
"base-type": "type/BigInteger"
}
]
]
},
"id": "[\"dimension\",[\"field\",23779,{\"base-type\":\"type/BigInteger\"}]]"
}
},
"targetId": 42,
"linkType": "question",
"type": "link"
}
}
}
},
"size_y": 8,
"dashboard_id": 4,
"created_at": "2025-01-02T00:50:37.328797Z",
"row": 5
},
{
"size_x": 12,
"dashboard_tab_id": null,
"series": [],
"action_id": null,
"collection_authority_level": null,
"card": {
"cache_invalidated_at": null,
"description": null,
"archived": false,
"view_count": 341,
"collection_position": null,
"table_id": 1074,
"result_metadata": [
{
"description": null,
"semantic_type": null,
"coercion_strategy": null,
"unit": "month",
"name": "project_complete_date",
"settings": null,
"fk_target_field_id": null,
"field_ref": [
"field",
23797,
{
"base-type": "type/Date",
"temporal-unit": "month"
}
],
"effective_type": "type/Date",
"id": 23797,
"visibility_type": "normal",
"display_name": "Project Complete Date",
"fingerprint": {
"global": {
"distinct-count": 6,
"nil%": 0.5454545454545455
},
"type": {
"type/DateTime": {
"earliest": "2023-06-15",
"latest": "2023-12-20"
}
}
},
"base_type": "type/Date"
},
{
"display_name": "Sum of Sum of Overbilled",
"field_ref": [
"aggregation",
0
],
"base_type": "type/Float",
"effective_type": "type/Float",
"name": "sum",
"semantic_type": null,
"fingerprint": {
"global": {
"distinct-count": 3,
"nil%": 0
},
"type": {
"type/Number": {
"min": 0,
"q1": 0,
"q3": 134057.87484316586,
"max": 267970.736225652,
"sd": 133961.216644664,
"avg": 67028.93742158292
}
}
}
},
{
"display_name": "Sum of Sum of Underbilled",
"field_ref": [
"aggregation",
1
],
"base_type": "type/Float",
"effective_type": "type/Float",
"name": "sum_2",
"semantic_type": null,
"fingerprint": {
"global": {
"distinct-count": 4,
"nil%": 0
},
"type": {
"type/Number": {
"min": -115565.89638309483,
"q1": -111224.34754893783,
"q3": -47571.65157422778,
"max": -4306.89,
"sd": 51098.08537038403,
"avg": -79397.99956158281
}
}
}
}
],
"initially_published_at": null,
"can_write": true,
"database_id": 2,
"enable_embedding": false,
"collection_id": null,
"query_type": "query",
"name": "Over / Under Billings by Completion Month",
"last_used_at": "2025-02-12T07:21:09.34919Z",
"type": "question",
"query_average_duration": 383,
"creator_id": 3,
"moderation_reviews": [],
"updated_at": "2025-01-02T14:53:02.871925Z",
"made_public_by_id": null,
"embedding_params": null,
"cache_ttl": null,
"dataset_query": {
"database": 2,
"type": "query",
"query": {
"breakout": [
[
"field",
23797,
{
"base-type": "type/Date",
"temporal-unit": "month"
}
]
],
"aggregation": [
[
"sum",
[
"field",
"sum_8",
{
"base-type": "type/Float"
}
]
],
[
"sum",
[
"field",
"sum_9",
{
"base-type": "type/Float"
}
]
]
],
"source-table": "card__40"
}
},
"id": 41,
"parameter_mappings": [],
"display": "bar",
"entity_id": "qAsoyIkqPnDAv_puxBRcg",
"collection_preview": true,
"visualization_settings": {
"series_settings": {
"sum_2": {
"color": "#E75454",
"title": "Underbilled"
},
"sum": {
"color": "#69C8C8",
"title": "Overbilled",
"display": "bar"
}
},
"graph.dimensions": [
"project_complete_date"
],
"graph.y_axis.auto_split": false,
"graph.metrics": [
"sum",
"sum_2"
]
},
"metabase_version": "v0.50.26 (5a65f46)",
"parameters": [],
"created_at": "2025-01-02T00:56:25.14879Z",
"public_uuid": null
},
"updated_at": "2025-01-02T14:51:18.473485Z",
"col": 12,
"id": 39,
"parameter_mappings": [
{
"parameter_id": "731098",
"card_id": 41,
"target": [
"dimension",
[
"field",
23834,
{
"base-type": "type/Text"
}
]
]
},
{
"parameter_id": "704e61f0",
"card_id": 41,
"target": [
"dimension",
[
"field",
23797,
{
"base-type": "type/Date"
}
]
]
},
{
"parameter_id": "ada0ab44",
"card_id": 41,
"target": [
"dimension",
[
"field",
23779,
{
"base-type": "type/BigInteger"
}
]
]
},
{
"parameter_id": "78d9663b",
"card_id": 41,
"target": [
"dimension",
[
"field",
23825,
{
"base-type": "type/Date"
}
]
]
}
],
"card_id": 41,
"entity_id": "32ivgZJwBAIbkKC_dmvHv",
"visualization_settings": {
"click_behavior": {
"type": "crossfilter",
"parameterMapping": {
"704e61f0": {
"source": {
"type": "column",
"id": "project_complete_date",
"name": "Project Complete Date"
},
"target": {
"type": "parameter",
"id": "704e61f0"
},
"id": "704e61f0"
}
}
}
},
"size_y": 5,
"dashboard_id": 4,
"created_at": "2025-01-02T00:57:28.87016Z",
"row": 0
},
{
"size_x": 12,
"dashboard_tab_id": null,
"series": [],
"action_id": null,
"collection_authority_level": null,
"card": {
"cache_invalidated_at": null,
"description": null,
"archived": false,
"view_count": 334,
"collection_position": null,
"table_id": 1074,
"result_metadata": [
{
"description": null,
"semantic_type": "type/CreationDate",
"coercion_strategy": null,
"unit": "month",
"name": "project_start_date",
"settings": null,
"fk_target_field_id": null,
"field_ref": [
"field",
23825,
{
"base-type": "type/Date",
"temporal-unit": "month"
}
],
"effective_type": "type/Date",
"id": 23825,
"visibility_type": "normal",
"display_name": "Project Start Date",
"fingerprint": {
"global": {
"distinct-count": 7,
"nil%": 0.3636363636363636
},
"type": {
"type/DateTime": {
"earliest": "2023-01-01",
"latest": "2023-07-01"
}
}
},
"base_type": "type/Date"
},
{
"display_name": "Sum of Sum of Overbilled",
"field_ref": [
"aggregation",
0
],
"base_type": "type/Float",
"effective_type": "type/Float",
"name": "sum",
"semantic_type": null,
"fingerprint": {
"global": {
"distinct-count": 4,
"nil%": 0
},
"type": {
"type/Number": {
"min": 0,
"q1": 18.731578192474664,
"q3": 70866.49316470022,
"max": 260223.1180090775,
"sd": 115541.01730265222,
"avg": 53623.14993726633
}
}
}
},
{
"display_name": "Sum of Sum of Underbilled",
"field_ref": [
"aggregation",
1
],
"base_type": "type/Float",
"effective_type": "type/Float",
"name": "sum_2",
"semantic_type": null,
"fingerprint": {
"global": {
"distinct-count": 4,
"nil%": 0
},
"type": {
"type/Number": {
"min": -206402.3095315504,
"q1": -131762.67641897322,
"q3": -556.32660873859,
"max": 0,
"sd": 92021.00286417615,
"avg": -63518.39964926625
}
}
}
}
],
"initially_published_at": null,
"can_write": true,
"database_id": 2,
"enable_embedding": false,
"collection_id": null,
"query_type": "query",
"name": "Over / Under Billings by Start Month",
"last_used_at": "2025-02-12T07:21:09.34919Z",
"type": "question",
"query_average_duration": 552,
"creator_id": 3,
"moderation_reviews": [],
"updated_at": "2025-01-02T14:52:39.301989Z",
"made_public_by_id": null,
"embedding_params": null,
"cache_ttl": null,
"dataset_query": {
"database": 2,
"type": "query",
"query": {
"breakout": [
[
"field",
23825,
{
"base-type": "type/Date",
"temporal-unit": "month"
}
]
],
"aggregation": [
[
"sum",
[
"field",
"sum_8",
{
"base-type": "type/Float"
}
]
],
[
"sum",
[
"field",
"sum_9",
{
"base-type": "type/Float"
}
]
]
],
"source-table": "card__40"
}
},
"id": 43,
"parameter_mappings": [],
"display": "bar",
"entity_id": "CoCw159k9IrCTihK55nqq",
"collection_preview": true,
"visualization_settings": {
"series_settings": {
"sum_2": {
"color": "#E75454",
"title": "Underbilled"
},
"sum": {
"color": "#69C8C8",
"title": "Overbilled",
"display": "bar"
}
},
"graph.dimensions": [
"project_start_date"
],
"graph.y_axis.auto_split": false,
"graph.metrics": [
"sum",
"sum_2"
]
},
"metabase_version": "v0.50.26 (5a65f46)",
"parameters": [],
"created_at": "2025-01-02T14:49:51.008272Z",
"public_uuid": null
},
"updated_at": "2025-01-02T14:51:18.473485Z",
"col": 0,
"id": 40,
"parameter_mappings": [
{
"parameter_id": "ada0ab44",
"card_id": 43,
"target": [
"dimension",
[
"field",
23779,
{
"base-type": "type/BigInteger"
}
]
]
},
{
"parameter_id": "731098",
"card_id": 43,
"target": [
"dimension",
[
"field",
23834,
{
"base-type": "type/Text"
}
]
]
},
{
"parameter_id": "78d9663b",
"card_id": 43,
"target": [
"dimension",
[
"field",
23825,
{
"base-type": "type/Date"
}
]
]
},
{
"parameter_id": "704e61f0",
"card_id": 43,
"target": [
"dimension",
[
"field",
23797,
{
"base-type": "type/Date"
}
]
]
}
],
"card_id": 43,
"entity_id": "FjX5FjgYaONdMjsqW7m8E",
"visualization_settings": {
"click_behavior": {
"type": "crossfilter",
"parameterMapping": {
"78d9663b": {
"source": {
"type": "column",
"id": "project_start_date",
"name": "Project Start Date"
},
"target": {
"type": "parameter",
"id": "78d9663b"
},
"id": "78d9663b"
}
}
}
},
"size_y": 5,
"dashboard_id": 4,
"created_at": "2025-01-02T14:50:21.303883Z",
"row": 0
}
],
"param_values": {
"23834": {
"field_id": 23834,
"human_readable_values": [],
"values": [
"Closed",
"Complete",
"Contract",
"Current"
]
},
"23779": {
"field_id": 23779,
"human_readable_values": [],
"values": [
1,
186,
201,
207,
215,
216,
220,
221,
222,
223,
224
]
}
},
"initially_published_at": null,
"can_write": true,
"tabs": [],
"enable_embedding": false,
"collection_id": null,
"show_in_getting_started": false,
"name": "Over / Under Billings Dashboard",
"width": "full",
"caveats": null,
"collection_authority_level": null,
"creator_id": 3,
"updated_at": "2025-01-14T22:27:12.356416Z",
"made_public_by_id": null,
"embedding_params": null,
"cache_ttl": null,
"last_used_param_values": {},
"id": 4,
"position": null,
"entity_id": "nkAqIgInUkF8cJUeDiV5_",
"param_fields": {
"23779": {
"semantic_type": "type/Quantity",
"table_id": 1074,
"name": "job_number",
"has_field_values": "list",
"fk_target_field_id": null,
"dimensions": [],
"id": 23779,
"target": null,
"display_name": "Job Number",
"name_field": null,
"base_type": "type/BigInteger"
},
"23797": {
"semantic_type": null,
"table_id": 1074,
"name": "project_complete_date",
"has_field_values": "none",
"fk_target_field_id": null,
"dimensions": [],
"id": 23797,
"target": null,
"display_name": "Project Complete Date",
"name_field": null,
"base_type": "type/Date"
},
"23825": {
"semantic_type": "type/CreationDate",
"table_id": 1074,
"name": "project_start_date",
"has_field_values": "none",
"fk_target_field_id": null,
"dimensions": [],
"id": 23825,
"target": null,
"display_name": "Project Start Date",
"name_field": null,
"base_type": "type/Date"
},
"23834": {
"semantic_type": "type/Category",
"table_id": 1074,
"name": "job_status",
"has_field_values": "list",
"fk_target_field_id": null,
"dimensions": [],
"id": 23834,
"target": null,
"display_name": "Job Status",
"name_field": null,
"base_type": "type/Text"
}
},
"last-edit-info": {
"id": 2,
"email": "mhagberg@jobxcel.ai",
"first_name": "Mike",
"last_name": "Hagberg",
"timestamp": "2025-01-14T22:27:12.385907Z"
},
"collection": {
"metabase.models.collection.root/is-root?": true,
"authority_level": null,
"name": "Our analytics",
"is_personal": false,
"id": "root",
"can_write": true
},
"parameters": [
{
"name": "Job Number",
"slug": "job_number",
"id": "ada0ab44",
"type": "number/=",
"sectionId": "number"
},
{
"name": "Job Status",
"slug": "job_status",
"id": "731098",
"type": "string/=",
"sectionId": "string"
},
{
"name": "Project Start Date",
"slug": "project_start_date",
"id": "78d9663b",
"type": "date/all-options",
"sectionId": "date"
},
{
"name": "Project Complete Date",
"slug": "project_complete_date",
"id": "704e61f0",
"type": "date/all-options",
"sectionId": "date"
},
{
"name": "Gross Profit > ",
"slug": "gross_profit_%3E_",
"id": "afa08c41",
"type": "number/>=",
"sectionId": "number"
}
],
"auto_apply_filters": true,
"created_at": "2025-01-02T00:48:22.390119Z",
"public_uuid": null,
"points_of_interest": null
}